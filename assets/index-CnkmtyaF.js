import{_ as d}from"./index-DtktVB_K.js";import{X as v,r as f,aa as A,v as g,L as $,k as w,_,z,G as O}from"./three-CWe9OjjT.js";class P{constructor(){this.supportCache=new Map,this.initializationPromise=this.initializeSupport()}async initializeSupport(){console.log("🔄 开始格式支持检测...");const[e,a]=await Promise.all([this.detectAVIFSupport(),this.detectWebPSupport()]);return this.supportCache.set("avif",e),this.supportCache.set("webp",a),console.log("🖼️ 图像格式支持检测完成:",{avif:e,webp:a,userAgent:navigator.userAgent.substring(0,100)}),this.supportCache}async detectAVIFSupport(){try{console.log("🔍 开始AVIF支持检测...");const e="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgABogQEAwgMg8f8D///8WfhwB8+ErK42A=";return new Promise(a=>{const t=new Image;t.onload=()=>{console.log("✅ AVIF支持检测: 成功"),a(!0)},t.onerror=s=>{console.log("❌ AVIF支持检测: 失败",s),a(!1)},t.src=e,setTimeout(()=>{console.log("⏰ AVIF支持检测: 超时"),a(!1)},3e3)})}catch(e){return console.warn("❌ AVIF检测异常:",e),!1}}async detectWebPSupport(){try{const e="data:image/webp;base64,UklGRjoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==";return new Promise(a=>{const t=new Image;t.onload=()=>a(!0),t.onerror=()=>a(!1),t.src=e})}catch(e){return console.warn("WebP检测异常:",e),!1}}async isFormatSupported(e){return await this.initializationPromise,this.supportCache.get(e.toLowerCase())||!1}async getAllSupport(){return await this.initializationPromise,Object.fromEntries(this.supportCache)}async getBestFormat(){await this.initializationPromise;const e=this.supportCache.get("avif"),a=this.supportCache.get("webp");let t;return e?t="avif":a?t="webp":t="jpg",console.log(`🎯 选择最佳格式: ${t.toUpperCase()} (AVIF支持: ${e}, WebP支持: ${a})`),t}async getCompressionInfo(){const e=await this.getBestFormat(),t={jpg:{ratio:1,description:"原始JPEG格式",quality:"baseline",compression:"无额外压缩"},webp:{ratio:.65,description:"WebP格式，平均减少35%文件大小",quality:"good",compression:"高效有损/无损压缩"},avif:{ratio:.45,description:"AVIF格式，平均减少55%文件大小",quality:"excellent",compression:"最新AV1编码，最佳压缩比"}}[e];return{format:e.toUpperCase(),...t,savings:Math.round((1-t.ratio)*100)}}}const m=new P,T=Object.freeze(Object.defineProperty({__proto__:null,FormatDetector:P,formatDetector:m},Symbol.toStringTag,{value:"Module"}));class x{constructor(e={}){this.loader=new v,this.cache=new Map,this.loadingPromises=new Map,this.config={enableCache:!0,enableFallback:!0,maxRetries:2,timeout:1e4,compression:{maxSize:1024,quality:.9},...e},this.defaultTextureSettings={generateMipmaps:!0,minFilter:$,magFilter:g,wrapS:A,wrapT:A,colorSpace:f}}async getOptimalPath(e,a="cube-textures"){console.log(`🔍 开始为 ${e} 获取最优路径...`);const t=await m.getBestFormat();console.log(`📋 检测到的最佳格式: ${t.toUpperCase()}`);const s=e.split("/").pop().replace(/\.(jpg|jpeg|png|webp|avif)$/i,""),o=s.startsWith("gallery-");console.log(`🔍 TextureLoader: 处理 ${e}, 文件名: ${s}, 格式: ${t}, 是Gallery图片: ${o}`);let r;o?(r={avif:`gallery-avif/${s}.avif`,webp:`gallery-webp/${s}.webp`,jpg:`gallery/${s}.jpg`},console.log("📁 使用Gallery目录结构:",r)):(r={avif:`cube-textures-avif/${e}.avif`,webp:`cube-textures-webp/${e}.webp`,jpg:`${a}/${e}.jpg`},console.log("📁 使用Cube目录结构:",r));const i={primary:r[t],fallback:r.jpg,format:t,isGalleryImage:o};return console.log(`🎯 选择的路径: 主要=${i.primary}, 备用=${i.fallback}`),i}async loadTexture(e,a={}){const t=`${e}_${JSON.stringify(a)}`;if(this.config.enableCache&&this.cache.has(t))return console.log(`📦 从缓存加载纹理: ${e}`),this.cache.get(t);if(this.loadingPromises.has(t))return this.loadingPromises.get(t);const s=this._loadTextureWithFallback(e,a);this.loadingPromises.set(t,s);try{const o=await s;return this.config.enableCache&&this.cache.set(t,o),o}finally{this.loadingPromises.delete(t)}}async _loadTextureWithFallback(e,a){const{primary:t,fallback:s,format:o}=await this.getOptimalPath(e),r=`/${t}`,i=`/${s}`;console.log(`🔄 开始加载纹理: ${e}`),console.log(`🎯 优选格式: ${o.toUpperCase()} -> ${r}`),console.log(`🔄 备用格式: JPG -> ${i}`);try{const c=await this._loadSingleTexture(r,a);return console.log(`✅ 纹理加载成功: ${r}`),c}catch(c){if(console.warn(`⚠️ 主格式加载失败: ${r}`,c),this.config.enableFallback&&o!=="jpg"){console.log(`🔄 回退到JPEG格式: ${i}`);try{const l=await this._loadSingleTexture(i,a);return console.log(`✅ 回退加载成功: ${i}`),l}catch(l){throw console.error(`❌ 回退也失败: ${i}`,l),l}}else throw c}}_loadSingleTexture(e,a){return new Promise((t,s)=>{const o=setTimeout(()=>{s(new Error(`纹理加载超时: ${e}`))},this.config.timeout);this.loader.load(e,r=>{clearTimeout(o),this._applyTextureSettings(r,a),t(r)},void 0,r=>{clearTimeout(o),s(r)})})}_applyTextureSettings(e,a={}){const t={...this.defaultTextureSettings,...a};return Object.keys(t).forEach(s=>{e[s]!==void 0&&(e[s]=t[s])}),e.needsUpdate=!0,e}async loadTextures(e,a={}){const{onProgress:t,onError:s}=a;console.log(`🎯 开始批量加载 ${e.length} 个纹理...`);let o=0;const r=[],i=e.map(async(l,u)=>{try{const h=await this.loadTexture(l,a);return r[u]=h,o++,t&&t(o/e.length,o,e.length),h}catch(h){return console.error(`纹理加载失败: ${l}`,h),s&&s(h,l),r[u]=null,o++,t&&t(o/e.length,o,e.length),null}});await Promise.allSettled(i);const c=r.filter(l=>l!==null).length;return console.log(`✨ 批量加载完成: ${c}/${e.length} 成功`),r}async preloadTextures(e,a={}){console.log(`⚡ 预加载 ${e.length} 个纹理...`);const t=e.map(r=>this.loadTexture(r,a).catch(i=>(console.warn(`预加载失败: ${r}`,i),null))),o=(await Promise.allSettled(t)).filter(r=>r.status==="fulfilled"&&r.value).length;return console.log(`⚡ 预加载完成: ${o}/${e.length} 成功`),o}getCachedTexture(e,a={}){const t=`${e}_${JSON.stringify(a)}`;return this.cache.get(t)}clearCache(){console.log(`🧹 清理纹理缓存，共 ${this.cache.size} 个纹理`),this.cache.forEach((e,a)=>{e&&e.dispose&&(e.dispose(),console.log(`🗑️ 释放纹理资源: ${a}`))}),this.cache.clear(),this.loadingPromises.clear(),console.log("✅ 纹理缓存已清理")}getCacheStats(){return{total:this.cache.size,loading:this.loadingPromises.size,memory:this._estimateMemoryUsage()}}_estimateMemoryUsage(){let e=0;return this.cache.forEach(a=>{if(a&&a.image){const t=a.image.width||0,s=a.image.height||0;e+=t*s*4}}),{bytes:e,mb:Math.round(e/(1024*1024)*100)/100}}}const B=new x,y=Object.freeze(Object.defineProperty({__proto__:null,TextureLoader:x,textureLoader:B},Symbol.toStringTag,{value:"Module"}));class L{constructor(e={}){this.textureLoader=new x(e),this.preloadQueue=new Map,this.loadingQueue=[],this.memoryThreshold=e.memoryThreshold||256,this.maxConcurrentLoads=e.maxConcurrentLoads||6,this.activeLoads=0,this.stats={totalLoads:0,successfulLoads:0,failedLoads:0,cacheHits:0,totalLoadTime:0},this._setupMemoryMonitoring()}async preloadByPriority(e){console.log("🚀 开始智能预加载...");const a=Object.entries(e).sort(([,t],[,s])=>(s.priority||0)-(t.priority||0));for(const[t,s]of a){console.log(`📦 预加载组: ${t} (优先级: ${s.priority||0})`);try{await this._preloadGroup(s)}catch(o){console.warn(`预加载组失败: ${t}`,o)}await this._checkMemoryUsage()}}async _preloadGroup(e){const{textures:a,lazy:t=!1,timeout:s=5e3}=e;if(t){a.forEach(o=>{this.preloadQueue.set(o,{timestamp:Date.now(),group:e})});return}return this.textureLoader.preloadTextures(a,{timeout:s})}async loadOnDemand(e,a="normal"){const t=performance.now();this.stats.totalLoads++;try{this.preloadQueue.has(e)&&this.preloadQueue.delete(e);const s=await this._throttledLoad(e,a);return this.stats.successfulLoads++,this.stats.totalLoadTime+=performance.now()-t,s}catch(s){throw this.stats.failedLoads++,s}}async _throttledLoad(e,a){return new Promise((t,s)=>{const o={textureName:e,priority:a,resolve:t,reject:s,timestamp:Date.now()};this.loadingQueue.push(o),this._processQueue()})}async _processQueue(){for(;this.loadingQueue.length>0&&this.activeLoads<this.maxConcurrentLoads;){this.loadingQueue.sort((a,t)=>{const s={high:3,normal:2,low:1};return(s[t.priority]||2)-(s[a.priority]||2)});const e=this.loadingQueue.shift();this.activeLoads++,this._executeLoad(e)}}async _executeLoad(e){const{textureName:a,resolve:t,reject:s}=e;try{const o=await this.textureLoader.loadTexture(a);t(o)}catch(o){s(o)}finally{this.activeLoads--,this._processQueue()}}async loadCubeTextures(e,a={}){const{onProgress:t,onComplete:s,enableOptimization:o=!0}=a;console.log(`🎯 开始加载Cube纹理集合: ${e.length}个`);const r=await m.getCompressionInfo();console.log(`📊 使用格式: ${r.format} (节省: ${r.savings}%)`);let i=0;const c=[],l=e.map(async(u,h)=>{try{const p=await this.loadOnDemand(u,"high");return o&&this._optimizeForCube(p),c[h]=p,i++,t&&t(i/e.length,i,e.length),p}catch(p){return console.error(`Cube纹理加载失败: ${u}`,p),c[h]=this._createFallbackTexture(),i++,t&&t(i/e.length,i,e.length),null}});return await Promise.allSettled(l),s&&s(c.filter(u=>u!==null)),console.log(`✨ Cube纹理集合加载完成: ${c.filter(u=>u!==null).length}/${e.length}`),c}_optimizeForCube(e){return e.wrapS=A,e.wrapT=A,e.minFilter=g,e.magFilter=g,e.generateMipmaps=!1,e.flipY=!1,e}_createFallbackTexture(){const e=document.createElement("canvas");e.width=256,e.height=256;const a=e.getContext("2d"),t=a.createLinearGradient(0,0,256,256);t.addColorStop(0,"#1a1a2e"),t.addColorStop(1,"#16213e"),a.fillStyle=t,a.fillRect(0,0,256,256),a.strokeStyle="#ffffff10",a.lineWidth=1;for(let o=0;o<256;o+=32)a.beginPath(),a.moveTo(o,0),a.lineTo(o,256),a.moveTo(0,o),a.lineTo(256,o),a.stroke();const s=new w(e);return this._optimizeForCube(s),s}_setupMemoryMonitoring(){setInterval(()=>{this._checkMemoryUsage()},3e4)}async _checkMemoryUsage(){const e=this.textureLoader.getCacheStats();e.memory.mb>this.memoryThreshold&&(console.warn(`⚠️ 纹理内存使用超限: ${e.memory.mb}MB > ${this.memoryThreshold}MB`),await this._performMemoryCleanup())}async _performMemoryCleanup(){console.log("🧹 开始纹理内存清理...");const e=Date.now(),a=300*1e3;for(const[t,s]of this.preloadQueue)e-s.timestamp>a&&this.preloadQueue.delete(t);console.log("🧹 内存清理完成")}getPerformanceStats(){const e=this.textureLoader.getCacheStats();return{...this.stats,cache:e,queue:{preload:this.preloadQueue.size,loading:this.loadingQueue.length,activeLoads:this.activeLoads},averageLoadTime:this.stats.totalLoads>0?Math.round(this.stats.totalLoadTime/this.stats.totalLoads):0,successRate:this.stats.totalLoads>0?Math.round(this.stats.successfulLoads/this.stats.totalLoads*100):100}}resetStats(){this.stats={totalLoads:0,successfulLoads:0,failedLoads:0,cacheHits:0,totalLoadTime:0}}dispose(){this.textureLoader.clearCache(),this.preloadQueue.clear(),this.loadingQueue.length=0,this.resetStats()}}const j=new L,S=Object.freeze(Object.defineProperty({__proto__:null,TextureManager:L,textureManager:j},Symbol.toStringTag,{value:"Module"}));class C{constructor(){this.cache=new Map,this.loadingPromises=new Map,this.sceneManagers=new Map,this.performanceStats={totalLoads:0,cacheHits:0,memoryUsage:0,errors:0},this.sceneConfigs={"hero-cube":{optimizer:this.cubeTextureOptimizer.bind(this),basePath:"/cube-textures",formats:["avif","webp","jpg"],fallback:this.createCubeFallback.bind(this)},gallery:{optimizer:this.galleryTextureOptimizer.bind(this),basePath:"/gallery",formats:["avif","webp","jpg"],fallback:this.createGalleryFallback.bind(this)},lightbox:{optimizer:this.lightboxTextureOptimizer.bind(this),basePath:"/gallery",formats:["avif","webp","jpg"],fallback:this.createLightboxFallback.bind(this)}}}async loadSceneTextures(e,a={}){console.log(`🎯 加载${e}场景纹理...`);const t=this.sceneConfigs[e];if(!t)throw new Error(`未知场景类型: ${e}`);return await m.initializationPromise,this.sceneManagers.has(e)||this.sceneManagers.set(e,new I(e,t)),await this.sceneManagers.get(e).loadTextures(a)}async getOptimalPath(e,a="cube-textures"){const t=await m.getBestFormat(),s=e.replace(/\.(jpg|jpeg|png|webp|avif)$/i,""),o={avif:`/${a}-avif/${s}.avif`,webp:`/${a}-webp/${s}.webp`,jpg:`/${a}/${s}.jpg`};return o[t]||o.jpg}cubeTextureOptimizer(e){return e.wrapS=A,e.wrapT=A,e.minFilter=g,e.magFilter=g,e.generateMipmaps=!1,e.flipY=!1,e.colorSpace=f,e}galleryTextureOptimizer(e){return e.wrapS=_,e.wrapT=_,e.minFilter=$,e.magFilter=g,e.generateMipmaps=!0,e.colorSpace=f,e}lightboxTextureOptimizer(e){return e.wrapS=A,e.wrapT=A,e.minFilter=g,e.magFilter=g,e.generateMipmaps=!1,e.colorSpace=f,e}createCubeFallback(){const e=document.createElement("canvas");e.width=e.height=256;const a=e.getContext("2d"),t=32;for(let o=0;o<8;o++)for(let r=0;r<8;r++)a.fillStyle=(o+r)%2===0?"#666":"#999",a.fillRect(o*t,r*t,t,t);const s=new w(e);return this.cubeTextureOptimizer(s)}createGalleryFallback(){const e=document.createElement("canvas");e.width=e.height=512;const a=e.getContext("2d"),t=a.createLinearGradient(0,0,512,512);t.addColorStop(0,"#f0f0f0"),t.addColorStop(1,"#d0d0d0"),a.fillStyle=t,a.fillRect(0,0,512,512),a.fillStyle="#999",a.font="24px Arial",a.textAlign="center",a.fillText("Loading...",256,256);const s=new w(e);return this.galleryTextureOptimizer(s)}createLightboxFallback(){const e=document.createElement("canvas");e.width=e.height=256;const a=e.getContext("2d");a.fillStyle="#222",a.fillRect(0,0,256,256);const t=a.createRadialGradient(128,128,0,128,128,128);t.addColorStop(0,"rgba(255,255,255,0.8)"),t.addColorStop(1,"rgba(255,255,255,0)"),a.fillStyle=t,a.fillRect(0,0,256,256);const s=new w(e);return this.lightboxTextureOptimizer(s)}cleanup(e){if(e){const a=this.sceneManagers.get(e);a&&(a.cleanup(),this.sceneManagers.delete(e))}else this.sceneManagers.forEach(a=>a.cleanup()),this.sceneManagers.clear(),this.cache.clear(),this.loadingPromises.clear()}getStats(){const e={};return this.sceneManagers.forEach((a,t)=>{e[t]=a.getStats()}),{global:this.performanceStats,scenes:e,totalCacheSize:this.cache.size,totalScenes:this.sceneManagers.size}}}class I{constructor(e,a){this.sceneType=e,this.config=a,this.textures=new Map,this.videos=new Map,this.stats={loaded:0,failed:0,cached:0}}async loadTextures(e={}){const{textures:a=[],videos:t=[],images:s=[],folder:o,onProgress:r}=e,i={textures:new Map,videos:new Map,errors:[]},c=[...a,...s];if(c.length>0){const l=await this.loadImageTextures(c,o,r);i.textures=l.textures,i.errors.push(...l.errors)}if(t.length>0){const l=await this.loadVideoTextures(t,r);i.videos=l.videos,i.errors.push(...l.errors)}return console.log(`✅ ${this.sceneType}场景加载完成: 
            - 图片: ${i.textures.size}
            - 视频: ${i.videos.size}
            - 错误: ${i.errors.length}`),i}async loadImageTextures(e,a,t){const s=new Map,o=[];let r=0;const i=e.map(async c=>{try{const l=a||this.config.basePath.replace("/",""),u=await m.getBestFormat(),h=c.replace(/\.(jpg|jpeg|png|webp|avif)$/i,""),p={avif:`/${l}-avif/${h}.avif`,webp:`/${l}-webp/${h}.webp`,jpg:`/${l}/${h}.jpg`},M=p[u]||p.jpg,E=await this.loadSingleTexture(M),F=this.config.optimizer(E);s.set(c,F),this.stats.loaded++,r++,t&&t(r/e.length,r,e.length)}catch(l){console.warn(`纹理加载失败: ${c}`,l);const u=this.config.fallback();s.set(c,u),o.push({name:c,error:l.message}),this.stats.failed++,r++,t&&t(r/e.length,r,e.length)}});return await Promise.allSettled(i),{textures:s,errors:o}}async loadVideoTextures(e,a){const t=new Map,s=[];let o=0;const r=e.map(async i=>{try{const{name:c,src:l}=i,u=await this.createVideoTexture(l);t.set(c,u),this.stats.loaded++,o++,a&&a(o/e.length,o,e.length)}catch(c){console.warn(`视频纹理加载失败: ${i.name}`,c),s.push({name:i.name,error:c.message}),this.stats.failed++,o++,a&&a(o/e.length,o,e.length)}});return await Promise.allSettled(r),{videos:t,errors:s}}async loadSingleTexture(e){return new Promise((a,t)=>{new v().load(e,a,void 0,t)})}async createVideoTexture(e){return new Promise((a,t)=>{const s=document.createElement("video");s.src=e,s.crossOrigin="anonymous",s.loop=!0,s.muted=!0,s.autoplay=!0,s.playsInline=!0,s.preload="metadata";const o=()=>{const r=new z(s);r.minFilter=g,r.magFilter=g,r.format=O,r.generateMipmaps=!1,r.flipY=!0,r.colorSpace=f,r.isVideoTexture=!0,s.play().then(()=>{console.log(`🎬 视频开始播放: ${e}`)}).catch(i=>{console.warn(`⚠️ 视频自动播放失败，需要用户交互: ${e}`,i)}),a(r)};s.addEventListener("loadeddata",o),s.addEventListener("error",t),s.load()})}cleanup(){this.textures.forEach(e=>e.dispose()),this.videos.forEach(e=>e.dispose()),this.textures.clear(),this.videos.clear()}getStats(){return{...this.stats,textureCount:this.textures.size,videoCount:this.videos.size}}}const D=new C,b=Object.freeze(Object.defineProperty({__proto__:null,TextureSystem:C,textureSystem:D},Symbol.toStringTag,{value:"Module"})),k={async getBestFormat(){const{formatDetector:n}=await d(async()=>{const{formatDetector:e}=await Promise.resolve().then(()=>T);return{formatDetector:e}},void 0);return n.getBestFormat()},async getCompressionInfo(){const{formatDetector:n}=await d(async()=>{const{formatDetector:e}=await Promise.resolve().then(()=>T);return{formatDetector:e}},void 0);return n.getCompressionInfo()},async loadTexture(n,e){const{textureLoader:a}=await d(async()=>{const{textureLoader:t}=await Promise.resolve().then(()=>y);return{textureLoader:t}},void 0);return a.loadTexture(n,e)},async loadCubeTextures(n,e){const{textureManager:a}=await d(async()=>{const{textureManager:t}=await Promise.resolve().then(()=>S);return{textureManager:t}},void 0);return a.loadCubeTextures(n,e)},async preloadTextures(n,e){const{textureLoader:a}=await d(async()=>{const{textureLoader:t}=await Promise.resolve().then(()=>y);return{textureLoader:t}},void 0);return a.preloadTextures(n,e)},getStats(){return{legacy:"使用 textureManager.getPerformanceStats() 获取传统系统统计",unified:"使用 textureSystem.getStats() 获取新系统统计"}},clearCache(){d(async()=>{const{textureManager:n}=await Promise.resolve().then(()=>S);return{textureManager:n}},void 0).then(({textureManager:n})=>{n.clearCache&&n.clearCache()}),d(async()=>{const{textureSystem:n}=await Promise.resolve().then(()=>b);return{textureSystem:n}},void 0).then(({textureSystem:n})=>{n.cleanup()})},async loadSceneTextures(n,e){const{textureSystem:a}=await d(async()=>{const{textureSystem:t}=await Promise.resolve().then(()=>b);return{textureSystem:t}},void 0);return a.loadSceneTextures(n,e)},async loadHeroCubeTextures(n){const e=n.filter(t=>t.texture).map(t=>t.texture),a=n.filter(t=>t.video).map(t=>({name:t.name,src:t.video}));return this.loadSceneTextures("hero-cube",{textures:e,videos:a})},async loadGalleryTextures(n,e={}){return this.loadSceneTextures("gallery",{images:n,folder:e.folder||"gallery",...e})},async getOptimalPath(n,e){if(e){const{textureSystem:a}=await d(async()=>{const{textureSystem:t}=await Promise.resolve().then(()=>b);return{textureSystem:t}},void 0);return a.getOptimalPath(n,e)}else{const{textureLoader:a}=await d(async()=>{const{textureLoader:t}=await Promise.resolve().then(()=>y);return{textureLoader:t}},void 0);return a.getOptimalPath(n)}}};export{k as t};
